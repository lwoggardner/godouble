/*
 * Copyright 2020 grant@lastweekend.com.au
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package doublegen

import (
	"fmt"
	"io"
	"log"
	"reflect"
	"strings"
	"text/template"
	"time"
)

type Interface struct {
	reflect.Type
	Package   string
	Timestamp time.Time
	TypeName  string
}
type Method struct {
	reflect.Method
	TypeName string
}

func NewGenerator(forInterface interface{}, configs ...func(*Interface)) Interface {

	doubleFor := reflect.TypeOf(forInterface).Elem()

	if doubleFor.Kind() != reflect.Interface {
		log.Panicf("Expecting %v to be a nil interface pointer", forInterface)
	}

	doubleForParts := strings.Split(doubleFor.String(), ".")
	iface := &Interface{
		Type:      doubleFor,
		Package:   doubleForParts[0],
		Timestamp: time.Now(),
		TypeName:  doubleForParts[1] + "Double",
	}
	for _, config := range configs {
		config(iface)
	}
	if iface.Package == "" || iface.TypeName == "" {
		log.Panicf("Expecting Package and TypeName to be set")
	}
	return *iface
}

func (iface *Interface) SetType(packageName string, typeName string) {
	iface.TypeName = typeName
	iface.Package = packageName
}

func (iface Interface) GenerateDouble(writer io.Writer) {
	t := template.New("Generate")
	iface.ParseTemplates(t)
	template.Must(t.Parse(GenerateTemplate))
	err := t.Execute(writer, iface)
	if err != nil {
		log.Fatal(err)
	}
	log.Printf("Generated Double for %v", iface)
}

func (iface Interface) packager(typeWithPkgIface interface{}) string {
	var typeWithPkg string
	switch t := typeWithPkgIface.(type) {
	case string:
		typeWithPkg = t
	case fmt.Stringer:
		typeWithPkg = t.String()
	default:
		log.Fatalf("Not stringable %v", typeWithPkgIface)
	}
	typeWithPkg = strings.Replace(typeWithPkg, "*"+iface.Package+".", "*", 1)
	typeWithPkg = strings.TrimPrefix(typeWithPkg, iface.Package+".")
	return typeWithPkg
}

func (iface Interface) ParseTemplates(t *template.Template) {
	t.Funcs(
		template.FuncMap{
			"packager": func(v interface{}) string {
				return iface.packager(v)
			}})
	template.Must(t.Parse(DoubleTemplate))
	template.Must(t.Parse(MethodTemplate))
	template.Must(t.Parse(PackageHeaderTemplate))
}

func (iface Interface) Methods() []Method {
	results := make([]Method, iface.NumMethod())
	for i := 0; i < iface.NumMethod(); i++ {
		results[i] = Method{Method: iface.Method(i), TypeName: iface.TypeName}
	}
	return results
}

func (gm Method) Args() []reflect.Type {
	results := make([]reflect.Type, gm.Type.NumIn())
	for i := 0; i < gm.Type.NumIn(); i++ {
		results[i] = gm.Type.In(i)
	}
	return results
}

func (gm Method) VariadicArg() int {
	if gm.Type.IsVariadic() {
		return gm.Type.NumIn() - 1
	} else {
		return -1
	}
}

func (gm Method) Returns() []reflect.Type {
	results := make([]reflect.Type, gm.Type.NumOut())
	for i := 0; i < gm.Type.NumOut(); i++ {
		results[i] = gm.Type.Out(i)
	}
	return results
}

const GenerateTemplate = `
{{template "PackageHeader" .}}
{{template "DoubleType" .}}
{{range .Methods}}
{{template "DoubleMethod" .}}
{{end}}
`

const PackageHeaderTemplate = `
{{define "PackageHeader"}}
// Code generated by go doublegen; DO NOT EDIT.
// This file was generated at {{ .Timestamp.Format "2006-01-02T15:04:05Z07:00" }}

// Package {{.Package}} provides a TestDouble implementation of {{.Type}}
package {{.Package}}
{{end}}
`

const DoubleTemplate = `
{{define "DoubleType"}}
{{- /*gotype: github.com/lwoggardner/godouble/doublegen.Interface*/ -}}
import "github.com/lwoggardner/godouble/godouble"

type {{.TypeName}} struct {
    {{packager .Type}}
    *godouble.TestDouble
}

func New{{.TypeName}}(t godouble.T,configurators ...func(*godouble.TestDouble)) *{{.TypeName}} {
    result := &{{.TypeName}}{}
    result.TestDouble = godouble.NewDouble(t,(*{{packager .Type}})(nil), configurators...)
    return result
}    
{{end}}
`
const MethodTemplate = `
{{define "DoubleMethod"}}
    {{- /*gotype: github.com/lwoggardner/godouble/doublegen.Method*/ -}}
{{- $variadic := .VariadicArg -}}
func (d *{{.TypeName}}) {{.Name}}({{range $i, $a := .Args}} i{{$i}} {{if eq $variadic $i}}...{{packager $a.Elem}}{{else}}{{packager $a}},{{end}}{{end}}) ({{range $i, $o := .Returns}}r{{$i}} {{packager $o}},{{end}}) {
    d.TestDouble.T().Helper()
    {{if .Returns}}returns := {{end}}d.TestDouble.Invoke("{{.Name}}"{{range $i, $a := .Args}},i{{$i}}{{end}})
{{- range $i,$o := .Returns }}
    r{{$i}}, _ = returns[{{$i}}].({{packager $o}})
{{- end}}
    {{if .Returns}}return{{end}}
}
{{end}}
`
